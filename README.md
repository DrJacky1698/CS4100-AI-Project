# CS4100-AI-Project
	For our project, we are working on creating a chess AI engine. Chess is a game that has been experiencing a resurgence in popularity over the past few years. I, Dimitar Ivanov, have personally become invested in it recently, and from my vantage point towards the back of the lecture hall, I’ve seen quite a number of students distracted by a chess game on their laptops. From a technical perspective, we felt that chess represented a good domain for exploration due to the fact that, while its rules are well known, the size and complexity of the search space those rules lead to allows us to increase the scope and ambition of our projects virtually indefinitely.
	For the sake of efficiency we didn’t start from scratch but rather followed this tutorial.  All related code from the tutorial could be found under the folder “ChessEngine”. It provided code and explanations for how to set up a chess harness using Python-Chess and PyChess for managing the state of the board and detecting events such as checkmates. It also took care of all graphical implementation details, including allowing mouse-based interactions with the board. This tutorial also included a basic minimax-based chess engine with a basic evaluation function as a proof of concept for how to connect the chess AI to other portions of the codebase, which is later revised and integrated into our own code base. Our goal was to create other more advanced search algorithms with more advanced evaluation functions that could outperform this built-in algorithm in both chess performance and efficiency.
  At a high level, the question our algorithm is trying to solve is simply what the best next move is for a given position. By then repeatedly querying our algorithm, and making the move it suggests, we have created a program that can play chess autonomously, either against itself or a person. At a more technical level, each turn our AI is given a string corresponding to which player's turn it is and a Python chess “board” by the chess harness, which is a data type representing a chessboard and all the pieces on it. Our turn algorithm's output is the best move, which is returned as a “move” object from the Python-Chess library. This move is then executed by the chess harness we are using in its main gameplay loop.
	The core of our approach is based around search. While we had originally hoped to create a fully reinforcement learning or machine learning-based agent, Professor Wong convinced us that the time needed to train such an agent would be beyond the timeframe of the project. We instead decided to create our own more advanced search-based algorithms and evaluation functions to replace those found in the tutorial. It is within several of these evaluation functions that we were able to incorporate various types of machine learning into our project.
	In order to use search to solve chess, we first need to conceptualize chess as a search problem. One state from the states base can be thought of as consisting of a chessboard with some or all pieces present in legal positions, along with a variable recording whether it is white or black turn. An action from the action space would be one of the legal moves that can be performed by any of the pieces present in a given state from the state space. The initial state would consist of a board with all the pieces in their starting positions and with a variable indicating that it is white's turn. The transition model’s responsibilities are handled by our chess harness, which takes in the legal move we selected through our search algorithm and returns the new board after the move has been made. We ourselves keep track of which side’s turn it is. The goal test takes in a state from the state space, and would traditionally return a reward of 0.5 if a draw has been reached, 1 if the position is a checkmate or 0 if the position is a loss. It is possible to have a draw due to repetition, but we don’t need to manage that ourselves because the python chess board object we are using keeps track of past positions for us, requiring us to only keep track of a single board. It also tells us when a goal state has been reached, although not with the traditional winning and losing values used in chess tournaments. We don’t need to consider a path cost for this search problem. The challenge in chess as a search problem is finding a desirable goal state in the near endless expanse of existing states.
